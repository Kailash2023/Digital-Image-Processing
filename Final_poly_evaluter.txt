`timescale 1ns / 1ps

module gf16_poly_eval (
    input  wire        clk,
    input  wire        rst,
    input  wire [3:0]  x,              // x as GF(16) index
    input  wire [59:0] C1,             // coefficients as GF(16) indices
    output reg  [3:0]  result          // final evaluated value index
);

    // FSM state parameters
    parameter IDLE = 3'd0;
    parameter INIT = 3'd1;
    parameter MUL  = 3'd2;
    parameter WAIT_MUL  = 3'd3;
    parameter XOR  = 3'd4;
    parameter WAIT_XOR  = 3'd5;
    parameter DONE = 3'd6;

    // BRAM interface signals
    reg  [3:0] bram_addr_gf_value;
    reg  [7:0] bram_addr_gf_xor;
    reg  [7:0] bram_addr_gf_mul;
    reg  [3:0] bram_addr_gf_inv;
    
    wire [3:0] gf_value;  // value from GF table (not needed for Horner, but available)
    wire [3:0] xor_idx;   // XOR table output (addition in GF)
    wire [3:0] mul_idx;   // MUL table output (multiplication in GF)
    wire [3:0] inv_idx;   // INV table output (inverse if needed)

    // Instantiate BRAMs
    blk_mem_gen_0 GF_values (
        .clka(clk), .ena(1'b1), .wea(1'b0),
        .addra(bram_addr_gf_value), .dina(3'd0), .douta(gf_value)
    );

    blk_mem_gen_1 gf_xor (
        .clka(clk), .ena(1'b1), .wea(1'b0),
        .addra(bram_addr_gf_xor), .dina(8'd0), .douta(xor_idx)
    );

    blk_mem_gen_2 gf_mul (
        .clka(clk), .ena(1'b1), .wea(1'b0),
        .addra(bram_addr_gf_mul), .dina(8'd0), .douta(mul_idx)
    );

    blk_mem_gen_3 GF_inv (
        .clka(clk), .ena(1'b1), .wea(1'b0),
        .addra(bram_addr_gf_inv), .dina(3'd0), .douta(inv_idx)
    );

    // Coefficient unpacking
    wire [3:0] C [14:0];
    assign C[0]  = C1[3:0];
    assign C[1]  = C1[7:4];
    assign C[2]  = C1[11:8];
    assign C[3]  = C1[15:12];
    assign C[4]  = C1[19:16];
    assign C[5]  = C1[23:20];
    assign C[6]  = C1[27:24];
    assign C[7]  = C1[31:28];
    assign C[8]  = C1[35:32];
    assign C[9]  = C1[39:36];
    assign C[10] = C1[43:40];
    assign C[11] = C1[47:44];
    assign C[12] = C1[51:48];
    assign C[13] = C1[55:52];
    assign C[14] = C1[59:56];

    // FSM control
    reg [2:0] state;
    reg [3:0] acc;
    reg [3:0] x_reg;
    reg [3:0] i;
    reg [3:0] temp_mul;

    always @(posedge clk) begin
        if (rst) begin
            state  <= IDLE;
            acc    <= 4'd0;
            result <= 4'd0;
            i      <= 4'd13;
            x_reg  <= 4'd0;
            bram_addr_gf_mul <= 8'h00;
            bram_addr_gf_xor <= 8'h00;
        end else begin
            case (state)
                IDLE: begin
                    x_reg <= x;
                    i     <= 4'd13;
                    state <= INIT;
                end

                INIT: begin
                    acc   <= C[14];
                    state <= MUL;
                end

                MUL: begin
                    bram_addr_gf_mul <= {acc, x_reg}; // acc * x
                    state     <= WAIT_MUL;
                    
                end
                
                WAIT_MUL: begin
                    temp_mul <= mul_idx;
                    state <= XOR;  
                end

                XOR: begin
                    
                    bram_addr_gf_xor <= {temp_mul, C[i]};
                    state     <= WAIT_XOR; 
                end
                
                WAIT_XOR: begin
                    acc <= xor_idx;
                    i   <= i - 1;
                    state <= (i == 0) ? DONE : MUL;  
                end

                DONE: begin
                    acc    <= xor_idx;
                    result <= xor_idx;
                    state  <= IDLE; // Ready for next evaluation
                end
            endcase
        end
    end
endmodule




/////////////////test_bench///////////////////////////////


`timescale 1ns / 1ps

module tb_gf16_poly_eval;

    // Testbench signals
    reg         clk;
    reg         rst;
    reg  [3:0]  x;
    reg  [59:0]  C1;
    wire [3:0]  result;

    // Clock generation: 10 ns period
    always #5 clk = ~clk;

    // DUT instantiation
    gf16_poly_eval uut (
        .clk(clk),
        .rst(rst),
        .x(x),
        .C1(C1),
        .result(result)
    );

    integer i;
    
    reg [3:0]  C [14:0];

    initial begin
        // Initialize
        clk = 1;
        rst = 1;
        x   = 4'd0;
        for (i = 0; i < 15; i = i + 1)
            C[i] = 4'd0;

        // Apply reset
        #20;
        rst = 0;

        // Test Vector 1: Simple polynomial
        // Example polynomial: P(x) = x^2 + x + 1 (in GF(16) indices)
        x     = 4'd6;       // Example GF(16) element index
        C[0]  = 4'd12;       // Constant term
        C[1]  = 4'd8;       // Coefficient for x^1
        C[2]  = 4'd3;       // Coefficient for x^2
        C[3]  = 4'd4;       // Constant term
        C[4]  = 4'd10;       // Coefficient for x^1
        C[5]  = 4'd8;       // Coefficient for x^2
        C[6]  = 4'd15;       // Constant term
        C[7]  = 4'd11;       // Coefficient for x^1
        C[8]  = 4'd0;       // Coefficient for x^2
        C[9]  = 4'd15;       // Constant term
        C[10]  = 4'd15;       // Coefficient for x^1
        C[11]  = 4'd15;       // Coefficient for x^2
        C[12]  = 4'd15;       // Constant term
        C[13]  = 4'd15;       // Coefficient for x^1
        C[14]  = 4'd15;       // Coefficient for x^2
        
        assign C1 = {C[14], C[13], C[12], C[11], C[10], C[9], C[8], C[7], C[6], C[5], C[4], C[3], C[2], C[1], C[0] };
        
        
        // Wait for the DUT to evaluate
        #2000;

        $display("Polynomial evaluated at x=%0d gives result=%0d", x, result);

        // End simulation
        #50;
        $stop;
    end

endmodule

